# 持久化机制

<cite>
**本文档中引用的文件**   
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py)
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py)
- [main.py](file://Agent-Trading-Arena/Stock_Main/main.py)
- [constant.py](file://Agent-Trading-Arena/Stock_Main/constant.py)
- [save/init/persona.json](file://Agent-Trading-Arena/Stock_Main/save/init/persona.json)
- [save/init/stocks.json](file://Agent-Trading-Arena/Stock_Main/save/init/stocks.json)
- [save/sim_test01/information.json](file://Agent-Trading-Arena/Stock_Main/save/sim_test01/information.json)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [核心持久化组件](#核心持久化组件)
3. [数据库初始化与表结构](#数据库初始化与表结构)
4. [CRUD操作实现](#crud操作实现)
5. [序列化策略与文件存储](#序列化策略与文件存储)
6. [事务管理与异常处理](#事务管理与异常处理)
7. [数据写入与时间戳机制](#数据写入与时间戳机制)
8. [存储场景对比分析](#存储场景对比分析)

## 项目结构

项目采用混合持久化策略，结合SQLite数据库和文件系统实现状态持久化。核心持久化相关文件位于`Stock_Main`目录下，主要包含数据库操作模块和序列化工具。

```mermaid
graph TD
subgraph "持久化层"
Database[(SQLite数据库)]
Filesystem[(文件系统)]
end
subgraph "核心模块"
DatabaseModule[database.py/database_utils.py]
SerializationModule[load_json.py]
end
subgraph "数据存储"
SaveDir[save/]
DataDB[data.db]
JSONFiles[*.json]
PickleFiles[*.pkl]
end
DatabaseModule --> Database
SerializationModule --> Filesystem
DatabaseModule --> SaveDir
SerializationModule --> SaveDir
```

**图示来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L245-L322)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L25-L77)
- [main.py](file://Agent-Trading-Arena/Stock_Main/main.py#L78-L85)

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L1-L322)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L1-L134)

## 核心持久化组件

系统通过`Database_operate`类和`save_all`/`load_all`函数实现双重持久化机制。`Database_operate`负责数据库层面的CRUD操作，而序列化函数则处理对象级别的状态保存。

```mermaid
classDiagram
class Database_operate {
+_db_name : str
+_conn : sqlite3.Connection
+_cur : sqlite3.Cursor
+__init__(db_name : str)
+init_database()
+execute_sql(cmd : str) : bool
+fetchall() : list
+close()
+cur : sqlite3.Cursor
}
class Serialization {
+save_all(virtual_date, iteration, stocks, market_index, persons, market, args)
+load_all(args)
+save_class(name, obj, Save_Path)
+load_class(name, args)
+load_persona(json_path)
+load_stocks(json_path)
}
Database_operate --> "1" Database : "连接"
Serialization --> "1" Filesystem : "读写"
Serialization --> "1" Database_operate : "数据库引用"
```

**图示来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L245-L322)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L25-L77)

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L245-L322)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L25-L77)

## 数据库初始化与表结构

`Database_operate`类在初始化时自动创建多个数据表，涵盖交易操作、股票行情、用户信息等核心实体。表结构设计体现了系统的领域模型。

```mermaid
erDiagram
OPERATIONS {
int timestamp PK
string virtual_date
int weekday
int iteration
string choice
int stock_id
int person_id
string action
numeric price
int quantity
int importance
}
ACTIVE_ORDERS {
int timestamp PK
int virtual_date
int weekday
int iteration
int stock_id
int person_id
string type
numeric price
int quantity
string status
}
STOCK {
int stock_id PK
int virtual_date PK
int weekday
numeric volume
int quantity
numeric last_price
numeric begin_price
numeric highest_price
numeric lowest_price
}
PERSON {
int person_id PK
int virtual_date PK
numeric cash
numeric asset
numeric wealth
numeric work_income
numeric capital_gain
numeric daily_expense
string principle
}
ACCOUNT {
int person_id PK
int stock_id PK
int virtual_date PK
int weekday
int quantity
numeric cost_price
numeric current_price
numeric profit
int start_date
}
MEMORY {
int person_id PK
int virtual_date PK
int iteration PK
string stock_operations
string strategy
string type
string gossip
string analysis_for_stocks
string analysis_for_strategy
string stock_prices
string market_change
string financial_situation
}
GOSSIP {
int person_id PK
int virtual_date PK
string gossip
}
OPERATIONS ||--o{ ACTIVE_ORDERS : "关联"
PERSON ||--o{ ACTIVE_ORDERS : "提交"
PERSON ||--o{ ACCOUNT : "持有"
PERSON ||--o{ MEMORY : "记录"
PERSON ||--o{ GOSSIP : "传播"
STOCK ||--o{ ACCOUNT : "关联"
STOCK ||--o{ ACTIVE_ORDERS : "交易"
```

**图示来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L253-L299)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L52-L60)

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L253-L299)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L52-L60)

## CRUD操作实现

系统通过封装的SQL执行方法实现CRUD操作，确保数据操作的一致性和安全性。`execute_sql`方法包含完整的异常处理和事务提交机制。

```mermaid
sequenceDiagram
participant Application as "应用程序"
participant DatabaseOperate as "Database_operate"
participant SQLite as "SQLite数据库"
Application->>DatabaseOperate : execute_sql(cmd)
DatabaseOperate->>DatabaseOperate : try-except块
DatabaseOperate->>SQLite : cur.execute(cmd)
SQLite-->>DatabaseOperate : 执行结果
DatabaseOperate->>SQLite : conn.commit()
SQLite-->>DatabaseOperate : 提交确认
alt 执行成功
DatabaseOperate-->>Application : 返回True
else 执行失败
DatabaseOperate->>DatabaseOperate : 打印错误信息
DatabaseOperate-->>Application : 返回False
end
Application->>DatabaseOperate : fetchall()
DatabaseOperate->>SQLite : cur.fetchall()
SQLite-->>DatabaseOperate : 查询结果
DatabaseOperate-->>Application : 返回结果列表
```

**图示来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L302-L310)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L63-L70)

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L302-L310)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L63-L70)

## 序列化策略与文件存储

系统采用JSON和Pickle混合序列化策略，JSON用于基础配置数据，Pickle用于复杂对象的完整状态保存。`save/`目录下的运行结果按时间戳组织。

```mermaid
flowchart TD
Start([保存所有状态]) --> CheckPath["检查保存路径存在性"]
CheckPath --> |不存在| CreatePath["创建路径 ./save/classes"]
CheckPath --> |存在| Continue
Continue --> RemoveDB["临时移除对象中的db引用"]
RemoveDB --> SerializeStocks["序列化股票对象为Pickle"]
SerializeStocks --> SerializePersons["序列化人员对象为Pickle"]
SerializePersons --> SerializeMarket["序列化市场对象为Pickle"]
SerializeMarket --> SaveInfo["保存虚拟日期和迭代信息为JSON"]
SaveInfo --> RestoreDB["恢复对象中的db引用"]
RestoreDB --> End([保存完成])
style CreatePath fill:#f9f,stroke:#333
style RemoveDB fill:#bbf,stroke:#333
style RestoreDB fill:#bbf,stroke:#333
```

**图示来源**
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L45-L77)
- [main.py](file://Agent-Trading-Arena/Stock_Main/main.py#L134)

**本节来源**
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L45-L77)
- [main.py](file://Agent-Trading-Arena/Stock_Main/main.py#L134)

## 事务管理与异常处理

系统在数据库操作层面实现了完整的事务管理，每个SQL命令执行后立即提交，确保数据一致性。同时，通过try-catch机制捕获并处理可能的数据库异常。

```mermaid
flowchart TD
Start([数据库操作开始]) --> ExecuteSQL["执行SQL命令"]
ExecuteSQL --> TryBlock["进入try块"]
TryBlock --> ExecuteCommand["cur.execute(cmd)"]
ExecuteCommand --> Commit["conn.commit()"]
Commit --> Success["返回True"]
TryBlock --> Exception["捕获异常"]
Exception --> LogError["打印错误信息"]
LogError --> ReturnFalse["返回False"]
Success --> End([操作完成])
ReturnFalse --> End
style TryBlock fill:#f96,stroke:#333
style Exception fill:#f66,stroke:#333
style LogError fill:#f66,stroke:#333
```

**图示来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L302-L310)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L63-L70)

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L302-L310)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L63-L70)

## 数据写入与时间戳机制

系统在数据写入时生成精确到毫秒的时间戳，确保操作的时序性和唯一性。通过`current_milli_time`函数获取当前时间戳，并在写入前添加微小延迟以避免冲突。

```mermaid
sequenceDiagram
participant Operation as "交易操作"
participant Time as "时间服务"
participant Database as "数据库"
Operation->>Time : current_milli_time()
Time-->>Operation : 返回毫秒级时间戳
Operation->>Operation : time.sleep(0.01)
Operation->>Database : 插入数据(含时间戳)
Database->>Database : 执行INSERT语句
Database-->>Operation : 确认写入
Note over Time,Database : 时间戳确保<br/>操作顺序和唯一性
```

**图示来源**
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L96)
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L10)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L101-L103)

**本节来源**
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L96)
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L10)
- [database.py](file://Agent-Trading-Arena/Stock_Main/database.py#L101-L103)

## 存储场景对比分析

系统根据数据特性和访问模式选择合适的存储策略。结构化、高频访问的数据使用数据库存储，而复杂对象状态和配置数据则采用文件存储。

| 存储特性 | 数据库存储 | 文件存储 |
|---------|----------|---------|
| **数据类型** | 结构化交易数据、实时行情 | 对象状态、配置信息 |
| **访问频率** | 高频读写 | 低频读写 |
| **数据量** | 大量小记录 | 少量大对象 |
| **查询需求** | 复杂查询、关联查询 | 全量读取、简单查询 |
| **性能要求** | 低延迟、高吞吐 | 一次性读写 |
| **一致性要求** | 强一致性 | 最终一致性 |
| **典型表/文件** | operations, active_orders | persona.json, stocks.json |
| **序列化方式** | SQL记录 | JSON/Pickle |
| **优势** | ACID特性、索引优化 | 简单直接、对象完整保存 |
| **劣势** | 连接开销、复杂性 | 无查询能力、并发问题 |

**本节来源**
- [database_utils.py](file://Agent-Trading-Arena/Stock_Main/database_utils.py#L253-L299)
- [load_json.py](file://Agent-Trading-Arena/Stock_Main/load_json.py#L45-L77)
- [main.py](file://Agent-Trading-Arena/Stock_Main/main.py#L134)
- [save/init/persona.json](file://Agent-Trading-Arena/Stock_Main/save/init/persona.json)
- [save/init/stocks.json](file://Agent-Trading-Arena/Stock_Main/save/init/stocks.json)